{"version":3,"file":"build-graph.js","sourceRoot":"","sources":["../../../src/lib/brocc/build-graph.ts"],"names":[],"mappings":";;AAQA;;;GAGG;AACH;IAAA;QACU,UAAK,GAAG,IAAI,GAAG,EAAgB,CAAC;IAuD1C,CAAC;IArDQ,GAAG,CAAC,KAAoB;QAC7B,EAAE,CAAC,CAAC,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC;YAC3B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QAC3C,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACrB,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAEO,MAAM,CAAC,IAAU;QACvB,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7B,+BAA+B;YAC/B,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACzC,OAAO,CAAC,YAAY,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC;QACjF,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;IACjC,CAAC;IAEM,GAAG,CAAC,GAAW;QACpB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IAEM,GAAG,CAAC,GAAW;QACpB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IAEM,OAAO;QACZ,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;QAEnC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC5B,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACjC,CAAC;IAEM,MAAM,CAAC,EAA2C;QACvD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACjC,CAAC;IAEM,IAAI,CAAC,IAAU;QACpB,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAED,IAAI,IAAI;QACN,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;IACzB,CAAC;CACF;AAxDD,gCAwDC","sourcesContent":["import { Node } from './node';\r\n\r\nexport interface Traversable<T> {\r\n  filter(by: (value: T, index: number) => boolean): T[];\r\n  find(by: (value: T, index: number) => boolean): T | undefined;\r\n  some(by: (value: T, index: number) => boolean): boolean;\r\n}\r\n\r\n/**\r\n * A tree of source files. Eventually, it's a graph. Ideally, it's an acyclic directed graph.\r\n * Technically, it's implemented as a map-like collection with references between map entries.\r\n */\r\nexport class BuildGraph implements Traversable<Node> {\r\n  private store = new Map<string, Node>();\r\n\r\n  public put(value: Node | Node[]) {\r\n    if (value instanceof Array) {\r\n      value.forEach(node => this.insert(node));\r\n    } else {\r\n      this.insert(value);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  private insert(node: Node) {\r\n    if (this.store.has(node.url)) {\r\n      // Clean up dependee references\r\n      const oldNode = this.store.get(node.url);\r\n      oldNode['_dependees'] = oldNode['_dependees'].filter(node => node !== oldNode);\r\n    }\r\n\r\n    this.store.set(node.url, node);\r\n  }\r\n\r\n  public get(url: string): Node {\r\n    return this.store.get(url);\r\n  }\r\n\r\n  public has(url: string): boolean {\r\n    return this.store.has(url);\r\n  }\r\n\r\n  public entries(): Node[] {\r\n    const values = this.store.values();\r\n\r\n    return Array.from(values);\r\n  }\r\n\r\n  public some(by: (value: Node, index: number) => boolean): boolean {\r\n    return this.entries().some(by);\r\n  }\r\n\r\n  public filter(by: (value: Node, index: number) => boolean): Node[] {\r\n    return this.entries().filter(by);\r\n  }\r\n\r\n  public find(by: (value: Node, index: number) => boolean): Node | undefined {\r\n    return this.entries().find(by);\r\n  }\r\n\r\n  public from(node: Node): Traversable<Node> {\r\n    return node;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.store.size;\r\n  }\r\n}\r\n"]}