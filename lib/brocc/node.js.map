{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../src/lib/brocc/node.ts"],"names":[],"mappings":";;AAAA,IAAI,UAAU,GAAG,CAAC,CAAC;AAIN,QAAA,WAAW,GAAc,OAAO,CAAC;AACjC,QAAA,gBAAgB,GAAc,aAAa,CAAC;AAC5C,QAAA,aAAa,GAAc,SAAS,CAAC;AACrC,QAAA,UAAU,GAAc,MAAM,CAAC;AAE5C;;GAEG;AACH;IACE,YAA4B,GAAW;QAAX,QAAG,GAAH,GAAG,CAAQ;QAMhC,UAAK,GAAc,EAAE,CAAC;QAkBrB,gBAAW,GAAW,EAAE,CAAC;QACzB,eAAU,GAAW,EAAE,CAAC;IAzBU,CAAC;IAQpC,MAAM,CAAC,EAA2C;QACvD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAED,IAAW,UAAU;QACnB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAKD,2IAA2I;IACpI,SAAS,CAAC,SAAwB;QACvC,MAAM,OAAO,GAAG,SAAS,YAAY,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAErE,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACpB,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACvE,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW;aAChC,MAAM,CAAC,QAAQ,CAAC,EAAE;YACjB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC;QACrD,CAAC,CAAC;aACD,MAAM,CAAC,OAAO,CAAC,CAAC;IACrB,CAAC;CACF;AA1CD,oBA0CC","sourcesContent":["let NODE_COUNT = 0;\r\n\r\nexport type NodeState = '' | 'dirty' | 'in-progress' | 'pending' | 'done';\r\n\r\nexport const STATE_DIRTY: NodeState = 'dirty';\r\nexport const STATE_IN_PROGESS: NodeState = 'in-progress';\r\nexport const STATE_PENDING: NodeState = 'pending';\r\nexport const STATE_DONE: NodeState = 'done';\r\n\r\n/**\r\n * A Node in the {@link BuildGraph}.\r\n */\r\nexport class Node {\r\n  constructor(public readonly url: string) {}\r\n\r\n  public type: string;\r\n\r\n  public data: any;\r\n\r\n  public state: NodeState = '';\r\n\r\n  public filter(by: (value: Node, index: number) => boolean): Node[] {\r\n    return this._dependents.filter(by);\r\n  }\r\n\r\n  public find(by: (value: Node, index: number) => boolean): Node | undefined {\r\n    return this._dependents.find(by);\r\n  }\r\n\r\n  public some(by: (value: Node, index: number) => boolean): boolean {\r\n    return this._dependents.some(by);\r\n  }\r\n\r\n  public get dependents(): Node[] {\r\n    return this._dependents;\r\n  }\r\n\r\n  private _dependents: Node[] = [];\r\n  private _dependees: Node[] = [];\r\n\r\n  /** @experimental DO NOT USE. For time being, dirty checking is for `type=entryPoint && state !== 'done'` (full rebuild of entry point). */\r\n  public dependsOn(dependent: Node | Node[]) {\r\n    const newDeps = dependent instanceof Array ? dependent : [dependent];\r\n\r\n    newDeps.forEach(dep => {\r\n      dep._dependees = dep._dependees.filter(d => d !== this).concat(this);\r\n    });\r\n\r\n    this._dependents = this._dependents\r\n      .filter(existing => {\r\n        return newDeps.some(newDep => newDep !== existing);\r\n      })\r\n      .concat(newDeps);\r\n  }\r\n}\r\n"]}