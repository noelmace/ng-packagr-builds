{"version":3,"file":"depth.js","sourceRoot":"","sources":["../../../src/lib/brocc/depth.ts"],"names":[],"mappings":"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","sourcesContent":["export type Token = string;\r\nexport type Depth = number;\r\n\r\n/**\r\n * Groups of tokens. The index is the depth value. The array value is a group of tokens.\r\n */\r\nexport type Groups = Token[][];\r\n\r\n/**\r\n * DepthBuilder calculates depth values for nodes and dependencies.\r\n *\r\n * Depth represents the furthest distance (number of edges) from a node w/o dependencies.\r\n * A depth of zero indicates that a node has no dependency.\r\n * Lower depth values indicate that a node need to be built prior to nodes with a higher depth.\r\n * Nodes with the same depth value may be built in parallel.\r\n *\r\n * #### Example\r\n *\r\n * A simple example:\r\n *\r\n *  - foo depends on bar\r\n *  - foo depends on foobar\r\n *  - bar depends on foobar\r\n *\r\n * Here, foobar has depth 0, bar has depth 1, and foo has depth 2.\r\n *\r\n * @link https://github.com/dherges/ng-packagr/pull/419#issuecomment-354015908\r\n */\r\nexport class DepthBuilder {\r\n  // this serves as a tracker for dependencies between tokens\r\n  private dependencyMap = new Map<Token, Token[]>();\r\n\r\n  public add(node: Token, dependencies: Token[] | Token = []) {\r\n    // Normalize to array\r\n    dependencies = dependencies instanceof Array ? dependencies : [dependencies];\r\n\r\n    if (this.dependencyMap.has(node)) {\r\n      // Add to existing and de-duplicate\r\n      const existing = this.dependencyMap.get(node);\r\n      const deps = existing.concat(dependencies).filter((value, index, self) => {\r\n        return self.indexOf(value) === index;\r\n      });\r\n      this.dependencyMap.set(node, deps);\r\n    } else {\r\n      this.dependencyMap.set(node, dependencies);\r\n    }\r\n\r\n    if (dependencies) {\r\n      for (const dependency of dependencies) {\r\n        if (!this.dependencyMap.has(dependency)) {\r\n          this.dependencyMap.set(dependency, []);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public build(): Groups {\r\n    const allNodes = Array.from(this.dependencyMap.entries()).map(([token, dependencies]) => ({ token, dependencies }));\r\n    // Start with root nodes and expand from there\r\n    const nodeQueue = allNodes.filter(node => node.dependencies.length === 0);\r\n\r\n    // Serves as a tracker for what nodes have been processed, and their furthest distance from a root node\r\n    const nodeDepths = new Map<Token, Depth>();\r\n    for (const node of nodeQueue) {\r\n      nodeDepths.set(node.token, 0);\r\n    }\r\n\r\n    // We will use this later to reduce the frequency of dynamic memory allocations\r\n    let maxDepth = 0;\r\n\r\n    // Walk the tree to determine longest path from root for each node\r\n    while (nodeQueue.length > 0) {\r\n      const currentNode = nodeQueue.pop();\r\n      const currentDepth = nodeDepths.get(currentNode.token) + 1;\r\n      if (currentDepth > maxDepth) {\r\n        maxDepth = currentDepth;\r\n      }\r\n\r\n      const parentNodes = allNodes.filter(node => node.dependencies.find(dep => dep === currentNode.token));\r\n      parentNodes.forEach(parent => {\r\n        if (!nodeDepths.has(parent.token)) {\r\n          // Push the dependency to the queue and track its depth\r\n          nodeQueue.push(parent);\r\n          nodeDepths.set(parent.token, currentDepth);\r\n        }\r\n\r\n        const dependencyDepth = nodeDepths.get(parent.token);\r\n        if (currentDepth > dependencyDepth) {\r\n          nodeDepths.set(parent.token, currentDepth);\r\n        }\r\n      });\r\n    }\r\n\r\n    // All nodes with the same max distance from a root can be run in parallel\r\n    // Now we need to bucket nodes by max depth\r\n    const buckets: Token[][] = new Array<Token[]>(maxDepth);\r\n    for (let i = 0; i < buckets.length; i++) {\r\n      buckets[i] = [];\r\n    }\r\n\r\n    nodeDepths.forEach((depth, node) => {\r\n      buckets[depth].push(node);\r\n    });\r\n\r\n    return buckets;\r\n  }\r\n}\r\n"]}